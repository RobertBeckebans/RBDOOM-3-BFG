/*
===========================================================================

Doom 3 BFG Edition GPL Source Code
Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
Copyright (C) 2014-2015 Robert Beckebans

This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  

Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.

In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.

If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.

===========================================================================
*/

#include "renderprogs/global.inc"

uniform sampler2D samp0		: register(s0);

struct PS_IN
{
	float4 position : VPOS;
	float2 texcoord0 : TEXCOORD0_centroid;
};

struct PS_OUT
{
	float4 color : COLOR;
};

float3 bloom_round_sampled( float2 sample_texcoord, bool achromatic, float exposure ) {
    const float gaussFact[9] = float[9](0.13298076, 0.12579441, 0.10648267, 0.08065691, 0.05467002, 0.03315905, 0.01799699, 0.00874063, 0.00379866);
    const float3 chromaticOffsets[9] = float3[](
	float3(0.5, 0.5, 0.5), // w
	float3(0.8, 0.3, 0.3),
//	float3(1.0, 0.2, 0.2), // r
	float3(0.5, 0.2, 0.8),
	float3(0.2, 0.2, 1.0), // b
	float3(0.2, 0.3, 0.9),
	float3(0.2, 0.9, 0.2), // g
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3)
	//float3(0.3, 0.5, 0.3)
	);
	const int samples = 9;
	
	float3 sum = float3( 0.0 );	
	
	float scale = 6.5; // bloom width
    float2 expansion = rpWindowCoord.xy * scale; //rpWindowCoord.xy being the samples of the effect
    const float weightScale = 2.3; // bloom strength //this is a magical number...
    float3 weight; 
	
	for( int i = 0; i < samples; i++ )
    {
        if ( achromatic ) {
            // no color tinting
            weight = float3( 1.0, 1.0, 1.0 ) * gaussFact[ i ] * weightScale;;
        } else {
            // old color tinting
            weight = chromaticOffsets[ i ] * weightScale * gaussFact[ i ];
        }

		float4 colour = tex2D( samp0, sample_texcoord + float2( float( i ), 0 ) * expansion );
        sum += colour.rgb * weight.rgb;
        colour = tex2D( samp0, sample_texcoord + float2( float( -i ), 0 ) * expansion );
        sum += colour.rgb * weight.rgb;
        colour = tex2D( samp0, sample_texcoord + float2( 0, float( i ) ) * expansion );
        sum += colour.rgb * weight.rgb;
        colour = tex2D( samp0, sample_texcoord + float2( 0, float( -i ) ) * expansion );
        sum += colour.rgb * weight.rgb;
	}
    return sum * exposure;
}

float3 bloom_streak_sampled( float2 sample_texcoord, float exposure ) {
    const float gaussFact[9] = float[9](0.13298076, 0.12579441, 0.10648267, 0.08065691, 0.05467002, 0.03315905, 0.01799699, 0.00874063, 0.00379866);
	const float3 chromaticOffsets[9] = float3[](
	float3(0.5, 0.5, 0.5), // w
	float3(0.8, 0.3, 0.3),
//	float3(1.0, 0.2, 0.2), // r
	float3(0.5, 0.2, 0.8),
	float3(0.2, 0.2, 1.0), // b
	float3(0.2, 0.3, 0.9),
	float3(0.2, 0.9, 0.2), // g
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3)
	//float3(0.3, 0.5, 0.3)
	);
	
	float3 sum = float3( 0.0 );
	const int samples = 9;
	
	float scale = 13.0; // bloom width
    float2 expansion = rpWindowCoord.xy * scale; //rpWindowCoord.xy being the samples of the effect
	const float weightScale = 2.3; // bloom strength //this is a magical number...

	for( int i = 0; i < samples; i++ )
    {
		
        float weight = gaussFact[ i ] * weightScale;
        float3 chormaOff = chromaticOffsets[ i ] * weight;
		float4 colour = tex2D( samp0, sample_texcoord + float2( float( i ), 0 ) * expansion );
        sum += colour.rgb * chormaOff.rgb;
        colour = tex2D( samp0, sample_texcoord + float2( float( -i ), 0 ) * expansion );
        sum += colour.rgb * chormaOff.rgb;
	}
    return sum * exposure;
}
/*
float3 bloom_streak_inverse_sampled( float2 sample_texcoord, float exposure ) {
    const float gaussFact[9] = float[9](0.13298076, 0.12579441, 0.10648267, 0.08065691, 0.05467002, 0.03315905, 0.01799699, 0.00874063, 0.00379866);
	const float3 chromaticOffsets[9] = float3[](
	float3(0.5, 0.5, 0.5), // w
	float3(0.8, 0.3, 0.3),
//	float3(1.0, 0.2, 0.2), // r
	float3(0.5, 0.2, 0.8),
	float3(0.2, 0.2, 1.0), // b
	float3(0.2, 0.3, 0.9),
	float3(0.2, 0.9, 0.2), // g
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3),
	float3(0.3, 0.5, 0.3)
	//float3(0.3, 0.5, 0.3)
	);
	
	float3 sum = float3( 0.0 );
	const int samples = 9;
	
	float scale = 13.0; // bloom width
    float2 expansion = rpWindowCoord.xy * scale; //rpWindowCoord.xy being the samples of the effect
    //float2 inversion = float2( -1, -1 );
	const float weightScale = 2.3; // bloom strength //this is a magical number...
    //float colour_reinforcement;
	
	for( int i = 0; i < samples; i++ )
    {
		
        float weight = gaussFact[ i ] * weightScale;
        float3 chormaOff = chromaticOffsets[ i ] * weight;
		float4 colour = tex2D( samp0, sample_texcoord + float2( float( i ), 0 ) * expansion );
        //colour_reinforcement = ( ( colour.r + colour.g + colour.b ) / 3 ) -1;
        sum += colour.rgb * chormaOff.rgb;// * colour_reinforcement;
        colour = tex2D( samp0, sample_texcoord + float2( float( -i ), 0 ) * expansion );
        //colour_reinforcement = ( ( colour.r + colour.g + colour.b ) / 3 ) -1;
        sum += colour.rgb * chormaOff.rgb;// * colour_reinforcement;
	}
    return sum * exposure;
}
*/

void main( PS_IN fragment, out PS_OUT result )
{
    float4 fog_bloom = float4( bloom_round_sampled( fragment.texcoord0, true, 0.175 ), 1.0 );
    float4 bloom_streak = float4( bloom_streak_sampled( fragment.texcoord0, 0.25 ), 1.0 );
	result.color = fog_bloom + bloom_streak; // + float4( bloom_streak_inverse_sampled( fragment.texcoord0 ), 1.0 );

}
